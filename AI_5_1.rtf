{\rtf1\ansi\ansicpg1251\cocoartf2511
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs24 \cf0 \
(setf state (list '(2 3 3) '(3 4 1) '(3 9 0)))\
\
(defun get-pos (a l &optional (pos 0))\
    (cond\
        ((null l) nil)\
        ((eql a (car l)) (print pos))\
        (t (get-pos a (cdr l) (+ 1 pos)))\
    )\
)\
 \
(defun get-coord (ls)\
    (do \
        (\
         (i 0 (+ i 1)) \
         (j ())\
         (pos ())\
        ) \
        ((numberp j) pos) \
        ((lambda(ls) (setf j (get-pos 0 (nth i ls))) (setf pos (list i j)) ) ls)\
    )\
)\
\
\
\
(setf position (get-coord state))\
(print position)\
\
(defun direction (pos) \
    (let ((drc ()))\
         (cond \
             ((equal '(0 0) pos)(setf drc '(up left)))\
             ((equal '(0 1) pos)(setf drc '(up right left)))\
             ((equal '(0 2) pos)(setf drc '(up right)))\
             ((equal '(1 0) pos)(setf drc '(up right down left)))\
             ((equal '(1 1) pos)(setf drc '(up right down)))\
             ((equal '(1 2) pos)(setf drc '(up down left)))\
             ((equal '(2 0) pos)(setf drc '(down left)))\
             ((equal '(2 1) pos)(setf drc '(right down left)))\
             ((equal '(2 2) pos)(setf drc '(right down)))\
         )\
         (progn drc)\
    )\
    \
)\
\
\
(setf direction (direction position))\
(print direction)\
\
;tmp is swapping element\
;i and j are indexes\
\
(defun up(st pos)\
    (let ((i ()) (j ()) (tmp ()) (s ()))\
         \
        (setf s (copy-tree st))\
        (setf i (first pos))\
        (setf j (second pos))\
         \
        ;get upping element - tmp\
        (setf tmp (nth j (nth (+ i 1) s)))\
        (print tmp)\
         \
        ;swapping 0 and tmp\
        (setf (nth j (nth i s)) tmp)\
        (setf (nth j (nth (+ i 1) s)) 0)\
	;also for swapping another way\
\
	;(replace (nth i1 state) (nth i2 state) :start1 j1 :end1 (+ j1 1) :start2 j2 :end2 (+ j2 1))\
	;(replace (nth i2 state) '(0) :start1 j2 :end1 (+ j2 1) :start2 0)\
        \
        (progn s);to return new state\
    )\
)\
\
(setf new-s-1(up state position))\
\
(print "returned state")\
(print new-s-1)\
(print "basic state")\
(print state)\
\
\
(defun right (st pos)\
    (let ((i ()) (j ()) (tmp ()) (s ()))\
        (setf s (copy-tree st))\
        (setf i (first pos))\
        (setf j (second pos))\
         \
        ;get upping element - tmp\
        (setf tmp (nth (- j 1) (nth i s)))\
        (print tmp)\
         \
        ;swapping 0 and tmp\
        (setf (nth j (nth i s)) tmp)\
        (setf (nth (- j 1) (nth i s)) 0)\
        \
        (progn s);to return new state\
    )\
)\
\
(setf new-s-2(right state position))\
\
(print "basic state")\
(print state)\
(print "right state ")\
(print new-s-2)\
\
\
\
\
\
}